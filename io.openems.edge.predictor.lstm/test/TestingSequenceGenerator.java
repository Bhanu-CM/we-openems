import static org.junit.Assert.fail;

import java.time.OffsetDateTime;
import java.util.ArrayList;

import org.junit.Test;

import io.openems.edge.predictor.lstm.common.HyperParameters;
import io.openems.edge.predictor.lstm.common.ReadCsv;
import io.openems.edge.predictor.lstm.interpolation.InterpolationManager;
import io.openems.edge.predictor.lstm.preprocessing.GroupBy;

public class TestingSequenceGenerator {
	/**
	 * Generates consecutive sequences of indices based on the specified length 'n' and the input list size.
	 *
	 * <p>This method prints consecutive sequences of indices from the input list. The sequences are generated by
	 * considering a starting offset and wrapping around the input list if necessary.</p>
	 *
	 * @param n           The length of each consecutive sequence.
	 * @param inputList   The input list of ArrayLists to generate sequences from.
	 */

	public static void generateConsecutiveSequences(int n, ArrayList<ArrayList<Double>> inputList) {
		int offset = 0;

		for (int i = 0; i < inputList.size(); i++) {

			for (int j = 0; j < n; j++) {
				if (j + offset < inputList.size()) {
					System.out.println(j + offset);
				} else {

					System.out.println(j + offset - inputList.size());

				}

			}

			offset++;

		}

	}

	@Test
	public void test() {
		String csvFileName = "1.csv";
		ArrayList<ArrayList<ArrayList<Double>>> dataGroupedByMinute = new ArrayList<ArrayList<ArrayList<Double>>>();
		ArrayList<ArrayList<ArrayList<OffsetDateTime>>> dateGroupedByMinute = new ArrayList<ArrayList<ArrayList<OffsetDateTime>>>();
		ArrayList<ArrayList<Double>> reShapeFirst = new ArrayList<ArrayList<Double>>();
		ReadCsv csv = new ReadCsv(csvFileName);
		ArrayList<Double> data = csv.getData();
		ArrayList<OffsetDateTime> date = csv.getDates();
		HyperParameters hyperParameters = HyperParameters.getInstance();
		//ArrayList<ArrayList<ArrayList<ArrayList<Double>>>> weightMatrix = new ArrayList<ArrayList<ArrayList<ArrayList<Double>>>>();
		InterpolationManager inter = new InterpolationManager(data, date, hyperParameters);
		//ArrayList<ArrayList<Double>> weight1 = new ArrayList<ArrayList<Double>>();
		//ArrayList<ArrayList<Double>> finalGroupedMatrix = new ArrayList<ArrayList<Double>>();

		GroupBy groupAsHour = new GroupBy(inter.getInterpolatedData(), date);
		groupAsHour.hour();

		for (int i = 0; i < groupAsHour.getDataGroupedByHour().size(); i++) {

			GroupBy groupAsMinute = new GroupBy(groupAsHour.getDataGroupedByHour().get(i),
					groupAsHour.getDateGroupedByHour().get(i));
			groupAsMinute.minute();
			dataGroupedByMinute.add(groupAsMinute.getDataGroupedByMinute());
			dateGroupedByMinute.add(groupAsMinute.getDateGroupedByMinute());
		}

		// rehsaping the grouped data step1 : Reshaping the dimension of the grouped
		// matrix :
		for (int i = 0; i < dataGroupedByMinute.size(); i++) {
			for (int j = 0; j < dataGroupedByMinute.get(i).size(); j++) {

				reShapeFirst.add(dataGroupedByMinute.get(i).get(j));
			}

		}
		generateConsecutiveSequences(hyperParameters.getWindowSizeTrend(), reShapeFirst);

		fail("Not yet implemented");
	}

}
